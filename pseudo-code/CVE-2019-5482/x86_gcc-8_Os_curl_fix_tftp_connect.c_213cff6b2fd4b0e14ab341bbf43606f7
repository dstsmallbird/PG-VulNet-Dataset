// bad sp value at call has been detected, the output may be wrong!
int __cdecl tftp_connect(int *a1, int a2)
{
  int v2; // eax
  int result; // eax
  int v4; // esi
  int v5; // edx
  int v6; // ecx
  int v7; // eax
  int v8; // eax
  int v9; // eax
  int v10; // ecx
  int *v11; // eax
  int v12; // edx
  char v13; // al
  int v14; // [esp-8h] [ebp-C0h]
  int v15; // [esp-4h] [ebp-BCh]
  int v16; // [esp+0h] [ebp-B8h]
  int v17; // [esp+0h] [ebp-B8h]
  int v18; // [esp+4h] [ebp-B4h]
  int v19; // [esp+4h] [ebp-B4h]
  int v20; // [esp+4h] [ebp-B4h]
  _BYTE *v21; // [esp+8h] [ebp-B0h]
  int (__cdecl **v22)(int, int, int, int); // [esp+Ch] [ebp-ACh]
  int v23; // [esp+Ch] [ebp-ACh]
  int v24; // [esp+10h] [ebp-A8h]
  int v25; // [esp+14h] [ebp-A4h]
  int v26; // [esp+18h] [ebp-A0h]
  int buf[35]; // [esp+1Ch] [ebp-9Ch] BYREF
  int v28; // [esp+A8h] [ebp-10h]

  buf[32] = __readgsdword(0x14u);
  v2 = Curl_ccalloc(
         1,
         336,
         v14,
         v15,
         v16,
         v18,
         a2,
         &Curl_ccalloc,
         v24,
         v25,
         v26,
         buf[0],
         buf[1],
         buf[2],
         buf[3],
         buf[4],
         buf[5],
         buf[6],
         buf[7],
         buf[8],
         buf[9],
         buf[10],
         buf[11],
         buf[12],
         buf[13],
         buf[14],
         buf[15],
         buf[16],
         buf[17],
         buf[18],
         buf[19],
         buf[20],
         buf[21],
         buf[22],
         buf[23],
         buf[24],
         buf[25],
         buf[26],
         buf[27],
         buf[28],
         buf[29],
         buf[30],
         buf[31]);
  a1[185] = v2;
  if ( !v2 )
    return 27;
  v4 = v2;
  result = *a1;
  v5 = *(_DWORD *)(*a1 + 1568);
  if ( v5 )
  {
    result = 71;
    if ( (unsigned int)(v5 - 8) > 0xFFB0 )
      return result;
    v6 = 512;
    if ( v5 >= 512 )
      v6 = *(_DWORD *)(*a1 + 1568);
  }
  else
  {
    v5 = 512;
    v6 = 512;
  }
  if ( !*(_DWORD *)(v4 + 328) )
  {
    v17 = v5;
    v19 = v6;
    result = (*v22)(1, v6 + 4, result, result);
    v6 = v19;
    v5 = v17;
    *(_DWORD *)(v4 + 328) = result;
    if ( !result )
      return 27;
  }
  if ( !*(_DWORD *)(v4 + 332) )
  {
    v20 = v5;
    result = (*v22)(1, v6 + 4, result, result);
    v5 = v20;
    *(_DWORD *)(v4 + 332) = result;
    if ( !result )
      return 27;
  }
  v28 = result;
  buf[34] = result;
  v23 = v5;
  Curl_conncontrol(a1, 1);
  v7 = a1[103];
  *(_DWORD *)(v4 + 16) = a1;
  *(_DWORD *)v4 = 0;
  *(_DWORD *)(v4 + 20) = v7;
  v8 = a1[18];
  *(_DWORD *)(v4 + 8) = -100;
  v9 = *(_DWORD *)(v8 + 4);
  *(_DWORD *)(v4 + 324) = v23;
  *(_DWORD *)(v4 + 320) = 512;
  *(_WORD *)(v4 + 52) = v9;
  tftp_set_timeouts();
  if ( (*((_BYTE *)a1 + 583) & 2) == 0 )
  {
    v28 = v10;
    if ( bind(*(_DWORD *)(v4 + 20), (const struct sockaddr *)(v4 + 52), *(_DWORD *)(a1[18] + 16)) )
    {
      v11 = __errno_location();
      v28 = v12;
      v13 = Curl_strerror(*v11, (char *)buf, 128);
      Curl_failf(*a1, "bind() failed; %s", v13);
      return 7;
    }
    *((_BYTE *)a1 + 583) |= 2u;
  }
  Curl_pgrsStartNow(*a1);
  *v21 = 1;
  return 0;
}
