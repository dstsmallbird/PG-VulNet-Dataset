char *__cdecl cache_insert(char *s, char *src, void *s1, int a4, __int16 a5)
{
  int v5; // eax
  char *v6; // eax
  char *v7; // eax
  char v9; // [esp+8h] [ebp-60h]
  bool v10; // [esp+23h] [ebp-45h]
  int v11[6]; // [esp+28h] [ebp-40h] BYREF
  char *v12; // [esp+40h] [ebp-28h]
  char *v13; // [esp+44h] [ebp-24h]
  int v14; // [esp+48h] [ebp-20h]
  int v15; // [esp+4Ch] [ebp-1Ch]
  int v16; // [esp+50h] [ebp-18h]
  char *dest; // [esp+54h] [ebp-14h]

  v16 = 0;
  v15 = a5 & 4;
  v14 = 0;
  if ( (a5 & 0x980) != 0 )
  {
    log_query((unsigned __int16)a5 | 0x10000, s, src, 0);
    if ( *((_DWORD *)dnsmasq_daemon + 63) && *((_DWORD *)dnsmasq_daemon + 63) < (unsigned int)a4 )
      a4 = *((_DWORD *)dnsmasq_daemon + 63);
    if ( *((_DWORD *)dnsmasq_daemon + 62) && *((_DWORD *)dnsmasq_daemon + 62) > (unsigned int)a4 )
      a4 = *((_DWORD *)dnsmasq_daemon + 62);
  }
  if ( insert_error )
    return 0;
  dest = (char *)cache_scan_free((int)s, (int)src, s1, a5);
  if ( dest )
  {
    if ( (a5 & 0x180) != 0 && (a5 & 8) != 0 )
    {
      if ( (a5 & 0x80) != 0 && (*((_WORD *)dest + 18) & 0x80) != 0 && *((_DWORD *)dest + 3) == *(_DWORD *)src )
        return dest;
      if ( (a5 & 0x100) != 0 && (*((_WORD *)dest + 18) & 0x100) != 0 )
      {
        v13 = dest + 12;
        v12 = src;
        v10 = 0;
        if ( *((_DWORD *)dest + 3) == *(_DWORD *)src )
        {
          v10 = 0;
          if ( *((_DWORD *)v13 + 1) == *((_DWORD *)v12 + 1) )
          {
            v10 = 0;
            if ( *((_DWORD *)v13 + 2) == *((_DWORD *)v12 + 2) )
              v10 = *((_DWORD *)v13 + 3) == *((_DWORD *)v12 + 3);
          }
        }
        v11[5] = v10;
        if ( v10 )
          return dest;
      }
    }
    insert_error = 1;
    return 0;
  }
  while ( 1 )
  {
    dest = (char *)cache_tail;
    if ( !cache_tail )
    {
      insert_error = 1;
      return 0;
    }
    if ( (*((_WORD *)dest + 18) & 0xC) == 0 )
      break;
    if ( v14 )
    {
      if ( !cache_insert_warned )
      {
        my_syslog(3, "Internal error in cache.", v9);
        cache_insert_warned = 1;
      }
      insert_error = 1;
      return 0;
    }
    if ( v15 )
    {
      v11[0] = *((_DWORD *)dest + 3);
      v11[1] = *((_DWORD *)dest + 4);
      v11[2] = *((_DWORD *)dest + 5);
      v11[3] = *((_DWORD *)dest + 6);
      v14 = 1;
      v5 = cache_get_name(dest);
      cache_scan_free(v5, (int)v11, s1, *((_WORD *)dest + 18));
      ++cache_live_freed;
    }
    else
    {
      cache_scan_free(0, 0, s1, 0);
      v15 = 1;
    }
  }
  if ( s && strlen(s) > 0x31 )
  {
    if ( big_free )
    {
      v16 = big_free;
      big_free = *(_DWORD *)big_free;
    }
    else
    {
      if ( !bignames_left && (a5 & 0x5000) == 0 || (v16 = whine_malloc(0x404u)) == 0 )
      {
        insert_error = 1;
        return 0;
      }
      if ( bignames_left )
        --bignames_left;
    }
  }
  cache_unlink(dest);
  *((_WORD *)dest + 18) = a5;
  if ( v16 )
  {
    *((_DWORD *)dest + 10) = v16;
    *((_WORD *)dest + 18) |= 0x200u;
  }
  if ( s )
  {
    v6 = (char *)cache_get_name(dest);
    strcpy(v6, s);
  }
  else
  {
    *(_BYTE *)cache_get_name(dest) = 0;
  }
  if ( src )
  {
    v7 = dest;
    *((_DWORD *)dest + 3) = *(_DWORD *)src;
    *((_DWORD *)v7 + 4) = *((_DWORD *)src + 1);
    *((_DWORD *)v7 + 5) = *((_DWORD *)src + 2);
    *((_DWORD *)v7 + 6) = *((_DWORD *)src + 3);
  }
  *((_DWORD *)dest + 7) = (char *)s1 + a4;
  *(_DWORD *)dest = new_chain;
  new_chain = (int)dest;
  return dest;
}
