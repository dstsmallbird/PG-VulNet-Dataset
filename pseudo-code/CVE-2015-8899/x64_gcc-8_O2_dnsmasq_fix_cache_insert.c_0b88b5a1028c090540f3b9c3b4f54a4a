__int64 __fastcall cache_insert(char *src, const __m128i *a2, __int64 a3, unsigned __int64 a4, unsigned __int16 a5)
{
  __int64 v9; // rbx
  __int64 v10; // rax
  int v11; // ecx
  int v12; // er8
  int v13; // er9
  int v15; // er10
  __int64 v16; // rdx
  unsigned __int16 v17; // ax
  __int64 v18; // rdi
  unsigned __int64 v19; // rax
  size_t v20; // rax
  __int64 *v21; // rcx
  __int64 v22; // rax
  char *v23; // rdi
  __int64 v24; // rax
  __int16 v25; // ax
  _BYTE *v26; // rax
  int v27; // [rsp+0h] [rbp-68h]
  __int64 v28; // [rsp+0h] [rbp-68h]
  __int64 v29; // [rsp+0h] [rbp-68h]
  __m128i v30; // [rsp+10h] [rbp-58h] BYREF
  unsigned __int64 v31; // [rsp+28h] [rbp-40h]

  v31 = __readfsqword(0x28u);
  if ( (a5 & 0x980) != 0 )
  {
    log_query(a5 | 0x10000u, src, a2, 0LL);
    v19 = *(_QWORD *)(dnsmasq_daemon + 456);
    if ( v19 >= a4 || !v19 )
      v19 = a4;
    a4 = *(_QWORD *)(dnsmasq_daemon + 448);
    if ( !a4 || a4 <= v19 )
      a4 = v19;
  }
  v9 = 0LL;
  v27 = insert_error;
  if ( insert_error )
    return v9;
  v10 = cache_scan_free(src, a2, a3, a5);
  v13 = v27;
  v9 = v10;
  if ( !v10 )
  {
    v15 = a5 & 4;
    while ( 1 )
    {
      v16 = cache_tail;
      if ( !cache_tail )
        goto LABEL_27;
      v17 = *(_WORD *)(cache_tail + 52);
      if ( (v17 & 0xC) == 0 )
        break;
      if ( v13 )
      {
        if ( !warned_8855 )
        {
          my_syslog(3, (unsigned int)"Internal error in cache.", warned_8855, v11, v12, v13, v27);
          warned_8855 = 1;
        }
        goto LABEL_27;
      }
      if ( v15 )
      {
        v30 = _mm_loadu_si128((const __m128i *)(cache_tail + 24));
        if ( (v17 & 0x200) != 0 || (v18 = cache_tail + 56, (v17 & 2) != 0) )
          v18 = *(_QWORD *)(cache_tail + 56);
        v27 = v15;
        cache_scan_free(v18, &v30, a3, v17);
        ++cache_live_freed;
        v13 = 1;
        v15 = v27;
      }
      else
      {
        LOBYTE(v27) = 0;
        cache_scan_free(0LL, 0LL, a3, 0LL);
        v13 = 0;
        v15 = 1;
      }
    }
    if ( src )
    {
      v28 = cache_tail;
      v20 = strlen(src);
      v16 = v28;
      if ( v20 > 0x31 )
      {
        v9 = big_free;
        if ( big_free )
        {
          big_free = *(_QWORD *)big_free;
        }
        else
        {
          if ( !bignames_left && (a5 & 0x5000) == 0 )
            goto LABEL_27;
          v9 = whine_malloc(1032LL);
          if ( !v9 )
            goto LABEL_27;
          v16 = v28;
          if ( bignames_left )
            --bignames_left;
        }
      }
    }
    else
    {
      v9 = 0LL;
    }
    v21 = *(__int64 **)(v16 + 8);
    v22 = *(_QWORD *)v16;
    if ( v21 )
    {
      *v21 = v22;
      v22 = *(_QWORD *)v16;
    }
    else
    {
      cache_head = *(_QWORD *)v16;
    }
    if ( v22 )
      *(_QWORD *)(v22 + 8) = v21;
    else
      cache_tail = (__int64)v21;
    *(_WORD *)(v16 + 52) = a5;
    if ( v9 )
    {
      *(_QWORD *)(v16 + 56) = v9;
      *(_WORD *)(v16 + 52) = a5 | 0x200;
      if ( src )
      {
LABEL_46:
        v23 = *(char **)(v16 + 56);
LABEL_47:
        v29 = v16;
        strcpy(v23, src);
        v16 = v29;
LABEL_48:
        if ( a2 )
          *(__m128i *)(v16 + 24) = _mm_loadu_si128(a2);
        v24 = new_chain;
        new_chain = v16;
        v9 = v16;
        *(_QWORD *)(v16 + 40) = a3 + a4;
        *(_QWORD *)v16 = v24;
        return v9;
      }
    }
    else
    {
      v25 = a5 & 0x200;
      if ( src )
      {
        if ( !v25 )
        {
          v23 = (char *)(v16 + 56);
          if ( (a5 & 2) == 0 )
            goto LABEL_47;
        }
        goto LABEL_46;
      }
      if ( !v25 )
      {
        v26 = (_BYTE *)(v16 + 56);
        if ( (a5 & 2) == 0 )
        {
LABEL_60:
          *v26 = 0;
          goto LABEL_48;
        }
      }
    }
    v26 = *(_BYTE **)(v16 + 56);
    goto LABEL_60;
  }
  if ( (a5 & 0x180) == 0
    || (a5 & 8) == 0
    || !a2
    || ((a5 & 0x80u) == 0 || *(char *)(v10 + 52) >= 0 || *(_DWORD *)(v10 + 24) != a2->m128i_i32[0])
    && ((a5 & 0x100) == 0
     || (*(_BYTE *)(v10 + 53) & 1) == 0
     || *(_DWORD *)(v10 + 24) != a2->m128i_i32[0]
     || *(_DWORD *)(v10 + 28) != a2->m128i_i32[1]
     || *(_DWORD *)(v10 + 32) != a2->m128i_i32[2]
     || *(_DWORD *)(v10 + 36) != a2->m128i_i32[3]) )
  {
LABEL_27:
    insert_error = 1;
    v9 = 0LL;
  }
  return v9;
}
