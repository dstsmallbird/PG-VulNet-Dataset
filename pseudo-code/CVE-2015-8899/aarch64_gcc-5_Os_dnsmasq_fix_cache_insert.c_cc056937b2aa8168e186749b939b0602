__int64 __fastcall cache_insert(const char *a1, __int64 a2, __int64 a3, unsigned __int64 a4, unsigned __int16 a5)
{
  unsigned int v6; // w20
  unsigned __int64 v10; // x0
  bool v11; // zf
  bool v12; // cf
  __int64 v13; // x19
  __int64 v14; // x0
  int v15; // w4
  int v16; // w5
  bool v17; // zf
  __int64 v18; // x1
  __int64 v19; // x0
  __int64 v20; // x3
  __int64 v21; // x4
  char *v22; // x0
  __int64 v23; // x3
  __int64 v24; // x0
  int v26; // [xsp+6Ch] [xbp+6Ch]
  _QWORD v27[2]; // [xsp+78h] [xbp+78h] BYREF

  v6 = a5;
  if ( (a5 & 0x980) != 0 )
  {
    log_query(a5 | 0x10000u, a1, a2, 0LL);
    v10 = *(_QWORD *)(dnsmasq_daemon + 456);
    if ( a4 > v10 )
      v11 = v10 == 0;
    else
      v11 = 1;
    if ( v11 )
      v10 = a4;
    a4 = *(_QWORD *)(dnsmasq_daemon + 448);
    if ( a4 )
      v12 = v10 >= a4;
    else
      v12 = 1;
    if ( v12 )
      a4 = v10;
  }
  v13 = 0LL;
  if ( !insert_error )
  {
    v14 = cache_scan_free(a1, a2, a3, v6);
    if ( !v14 )
    {
      v15 = v6 & 4;
      v16 = 0;
      while ( 1 )
      {
        v13 = cache_tail;
        if ( !cache_tail )
          goto LABEL_31;
        if ( (*(_WORD *)(cache_tail + 52) & 0xC) == 0 )
        {
          if ( a1 && strlen(a1) > 0x31 )
          {
            if ( big_free )
            {
              big_free = *(_QWORD *)big_free;
            }
            else
            {
              if ( !bignames_left && (v6 & 0x5000) == 0 || !whine_malloc(1032LL) )
                goto LABEL_31;
              if ( bignames_left )
                --bignames_left;
            }
          }
          cache_unlink(v13);
          *(_WORD *)(v13 + 52) = v6;
          if ( v21 )
          {
            *(_QWORD *)(v13 + 56) = v21;
            *(_WORD *)(v13 + 52) = v6 | 0x200;
          }
          if ( a1 )
          {
            v22 = (char *)cache_get_name(v13);
            strcpy(v22, a1);
          }
          else
          {
            *(_BYTE *)cache_get_name(v13) = 0;
          }
          if ( a2 )
          {
            v23 = *(_QWORD *)(a2 + 8);
            *(_QWORD *)(v13 + 24) = *(_QWORD *)a2;
            *(_QWORD *)(v13 + 32) = v23;
          }
          *(_QWORD *)(v13 + 40) = a4 + a3;
          v24 = new_chain;
          new_chain = v13;
          *(_QWORD *)v13 = v24;
          return v13;
        }
        if ( v16 )
        {
          if ( !warned_9531 )
          {
            my_syslog(3LL, "Internal error in cache.");
            warned_9531 = 1;
          }
          goto LABEL_31;
        }
        v26 = v15;
        if ( v15 )
        {
          v18 = *(_QWORD *)(cache_tail + 32);
          v27[0] = *(_QWORD *)(cache_tail + 24);
          v27[1] = v18;
          v19 = cache_get_name(cache_tail);
          cache_scan_free(v19, v27, a3, v20);
          v16 = 1;
          v15 = v26;
          ++cache_live_freed;
        }
        else
        {
          cache_scan_free(0LL, 0LL, a3, 0LL);
          v15 = 1;
          v16 = 0;
        }
      }
    }
    if ( (v6 & 0x180) == 0
      || ((v6 & 8) != 0 ? (v17 = a2 == 0) : (v17 = 1),
          v17
       || ((v6 & 0x80) == 0 || (*(_WORD *)(v14 + 52) & 0x80) == 0 || (v13 = v14, *(_DWORD *)(v14 + 24) != *(_DWORD *)a2))
       && ((v6 & 0x100) == 0
        || (*(_WORD *)(v14 + 52) & 0x100) == 0
        || *(_DWORD *)(v14 + 24) != *(_DWORD *)a2
        || *(_DWORD *)(v14 + 28) != *(_DWORD *)(a2 + 4)
        || *(_DWORD *)(v14 + 32) != *(_DWORD *)(a2 + 8)
        || (v13 = v14, *(_DWORD *)(v14 + 36) != *(_DWORD *)(a2 + 12)))) )
    {
LABEL_31:
      v13 = 0LL;
      insert_error = 1;
      return v13;
    }
  }
  return v13;
}
